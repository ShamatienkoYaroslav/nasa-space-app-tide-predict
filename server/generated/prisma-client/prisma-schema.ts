// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateExtreme {
  count: Int!
}

type AggregateStation {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Extreme {
  id: ID!
  lat: Float!
  lng: Float!
  dt: DateTime!
  height: Float
  type: String
}

type ExtremeConnection {
  pageInfo: PageInfo!
  edges: [ExtremeEdge]!
  aggregate: AggregateExtreme!
}

input ExtremeCreateInput {
  id: ID
  lat: Float
  lng: Float
  dt: DateTime!
  height: Float
  type: String
}

type ExtremeEdge {
  node: Extreme!
  cursor: String!
}

enum ExtremeOrderByInput {
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  dt_ASC
  dt_DESC
  height_ASC
  height_DESC
  type_ASC
  type_DESC
}

type ExtremePreviousValues {
  id: ID!
  lat: Float!
  lng: Float!
  dt: DateTime!
  height: Float
  type: String
}

type ExtremeSubscriptionPayload {
  mutation: MutationType!
  node: Extreme
  updatedFields: [String!]
  previousValues: ExtremePreviousValues
}

input ExtremeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExtremeWhereInput
  AND: [ExtremeSubscriptionWhereInput!]
  OR: [ExtremeSubscriptionWhereInput!]
  NOT: [ExtremeSubscriptionWhereInput!]
}

input ExtremeUpdateInput {
  lat: Float
  lng: Float
  dt: DateTime
  height: Float
  type: String
}

input ExtremeUpdateManyMutationInput {
  lat: Float
  lng: Float
  dt: DateTime
  height: Float
  type: String
}

input ExtremeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  dt: DateTime
  dt_not: DateTime
  dt_in: [DateTime!]
  dt_not_in: [DateTime!]
  dt_lt: DateTime
  dt_lte: DateTime
  dt_gt: DateTime
  dt_gte: DateTime
  height: Float
  height_not: Float
  height_in: [Float!]
  height_not_in: [Float!]
  height_lt: Float
  height_lte: Float
  height_gt: Float
  height_gte: Float
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  AND: [ExtremeWhereInput!]
  OR: [ExtremeWhereInput!]
  NOT: [ExtremeWhereInput!]
}

input ExtremeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createExtreme(data: ExtremeCreateInput!): Extreme!
  updateExtreme(data: ExtremeUpdateInput!, where: ExtremeWhereUniqueInput!): Extreme
  updateManyExtremes(data: ExtremeUpdateManyMutationInput!, where: ExtremeWhereInput): BatchPayload!
  upsertExtreme(where: ExtremeWhereUniqueInput!, create: ExtremeCreateInput!, update: ExtremeUpdateInput!): Extreme!
  deleteExtreme(where: ExtremeWhereUniqueInput!): Extreme
  deleteManyExtremes(where: ExtremeWhereInput): BatchPayload!
  createStation(data: StationCreateInput!): Station!
  updateStation(data: StationUpdateInput!, where: StationWhereUniqueInput!): Station
  updateManyStations(data: StationUpdateManyMutationInput!, where: StationWhereInput): BatchPayload!
  upsertStation(where: StationWhereUniqueInput!, create: StationCreateInput!, update: StationUpdateInput!): Station!
  deleteStation(where: StationWhereUniqueInput!): Station
  deleteManyStations(where: StationWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  extreme(where: ExtremeWhereUniqueInput!): Extreme
  extremes(where: ExtremeWhereInput, orderBy: ExtremeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Extreme]!
  extremesConnection(where: ExtremeWhereInput, orderBy: ExtremeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExtremeConnection!
  station(where: StationWhereUniqueInput!): Station
  stations(where: StationWhereInput, orderBy: StationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Station]!
  stationsConnection(where: StationWhereInput, orderBy: StationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StationConnection!
  node(id: ID!): Node
}

type Station {
  id: ID!
  wtId: String!
  name: String!
  lat: Float!
  lng: Float!
}

type StationConnection {
  pageInfo: PageInfo!
  edges: [StationEdge]!
  aggregate: AggregateStation!
}

input StationCreateInput {
  id: ID
  wtId: String!
  name: String!
  lat: Float!
  lng: Float!
}

type StationEdge {
  node: Station!
  cursor: String!
}

enum StationOrderByInput {
  id_ASC
  id_DESC
  wtId_ASC
  wtId_DESC
  name_ASC
  name_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
}

type StationPreviousValues {
  id: ID!
  wtId: String!
  name: String!
  lat: Float!
  lng: Float!
}

type StationSubscriptionPayload {
  mutation: MutationType!
  node: Station
  updatedFields: [String!]
  previousValues: StationPreviousValues
}

input StationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StationWhereInput
  AND: [StationSubscriptionWhereInput!]
  OR: [StationSubscriptionWhereInput!]
  NOT: [StationSubscriptionWhereInput!]
}

input StationUpdateInput {
  wtId: String
  name: String
  lat: Float
  lng: Float
}

input StationUpdateManyMutationInput {
  wtId: String
  name: String
  lat: Float
  lng: Float
}

input StationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  wtId: String
  wtId_not: String
  wtId_in: [String!]
  wtId_not_in: [String!]
  wtId_lt: String
  wtId_lte: String
  wtId_gt: String
  wtId_gte: String
  wtId_contains: String
  wtId_not_contains: String
  wtId_starts_with: String
  wtId_not_starts_with: String
  wtId_ends_with: String
  wtId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  AND: [StationWhereInput!]
  OR: [StationWhereInput!]
  NOT: [StationWhereInput!]
}

input StationWhereUniqueInput {
  id: ID
  wtId: String
}

type Subscription {
  extreme(where: ExtremeSubscriptionWhereInput): ExtremeSubscriptionPayload
  station(where: StationSubscriptionWhereInput): StationSubscriptionPayload
}
`